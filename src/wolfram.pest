WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "(*" ~ (!"*)" ~ ANY)* ~ "*)" }

PartExtract = { (List | Identifier) ~ "[[" ~ Expression ~ "]]" }

Integer = @{ ("-")? ~ ASCII_DIGIT+ }
Real = @{ ("-")? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
UnsignedInteger = @{ ASCII_DIGIT+ }
UnsignedReal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
Constant = { ("-")? ~ "Pi" }
NumericValue = { Real | Integer | Constant }
UnsignedNumericValue = { UnsignedReal | UnsignedInteger | Constant }

// PatternName is an identifier that will be followed by _ in a Pattern
// It must start with a letter and can contain letters, digits, but NOT trailing underscores
PatternName = @{ ASCII_ALPHA ~ ASCII_ALPHANUMERIC* }
Identifier = @{ (ASCII_ALPHA | "_" | "$") ~ (ASCII_ALPHANUMERIC | "_")* }
String = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Anonymous function syntax: body & where body contains # slots
Slot = @{ "#" ~ ASCII_DIGIT* }
// SimpleAnonymousFunction is # or # op term followed by & (not &&)
SimpleAnonymousFunction = { Slot ~ (Operator ~ SlotTerm)? ~ "&" ~ !"&" }
// SlotTerm is what can follow an operator in a simple anonymous function
SlotTerm = _{ NumericValue | Constant | String | Identifier | Slot | "(" ~ Expression ~ ")" }
// FunctionAnonymousFunction is a function call (like If[...]) followed by & (not &&)
FunctionAnonymousFunction = { BaseFunctionCall ~ "&" ~ !"&" }
// ParenAnonymousFunction handles (Expression)& - for expressions like (# === "")&
ParenAnonymousFunction = { "(" ~ Expression ~ ")" ~ "&" ~ !"&" }
// ListAnonymousFunction handles {expr1, expr2, ...}& - for expressions like {#1, #2}&
ListAnonymousFunction = { List ~ "&" ~ !"&" }
// BaseFunctionCall is a function call that doesn't include anonymous functions to avoid recursion
BaseFunctionCall = { Identifier ~ ("[" ~ (FunctionArg ~ ("," ~ FunctionArg)*)? ~ "]")+ }

Operator = {
    "/@"     // keep first
  | "@@@"    // MapApply operator (must be before @@)
  | "@@"     // Apply operator (must be before single @)
  | "<>"     // StringJoin operator (must be before < and >)
  | "&&"     // And operator (must be before single &)
  | "||"     // Or operator
  | "===" | "=!=" | "==" | "!="  // SameQ, UnsameQ (must be before == and !=), Equal, Unequal
  | "<=" | ">="
  | ":="
  | "+" | "-" | "*" | "/" | "^"
  | "<" | ">"
  | "=" | "@"
}

// PostfixFunction: function used in postfix application (x // f or x // Map[f])
// Uses BaseFunctionCall to avoid circular reference with FunctionCall -> FunctionArg -> Expression -> PostfixApplication
PostfixFunction = { BaseFunctionCall | Identifier }

// ImplicitTimes handles implicit multiplication (e.g., "x y z" or "2 x")
ImplicitTimes = { SimpleTerm ~ SimpleTerm+ }

// Unified Expression: parses a base term/operators, then looks for optional postfix/replace operators
// This avoids redundant parsing by checking for special operators after the main parse
// Postfix application (//) has lowest precedence and can follow any expression form
Expression = {
    Term ~ (
        ("//." ~ (List | ReplacementRule)) |  // ReplaceRepeated: x //. rule
        ("/." ~ (List | ReplacementRule)) |   // ReplaceAll: x /. rule
        (Operator ~ Term)*                    // Regular operators: x + y, etc.
    )
    ~ ("//" ~ PostfixFunction)*               // Postfix application (lowest precedence): x // f
}

// Legacy rules kept for backward compatibility in evaluation code
PostfixBase = { ReplaceRepeatedExpr | ReplaceAllExpr | Term }
PostfixApplication = { PostfixBase ~ ("//" ~ PostfixFunction)+ }

// CompoundExpression: multiple expressions separated by ;
// The result is the value of the last expression (like Wolfram's CompoundExpression)
CompoundExpression = { Expression ~ (";" ~ Expression)+ }
Term = _{
    PartExtract
  | NumericValue
  | Constant
  | String
  | ListAnonymousFunction
  | List
  | FunctionAnonymousFunction
  | ParenAnonymousFunction
  | FunctionCall
  | SimpleAnonymousFunction
  | ImplicitTimes
  | Identifier
  | Slot
  | Association
  | "(" ~ (CompoundExpression | Expression) ~ ")"
}

// SimpleTerm is used for implicit multiplication - doesn't include ImplicitTimes to avoid recursion
// Uses UnsignedNumericValue to prevent "n-1" from being parsed as implicit multiplication n*(-1)
SimpleTerm = _{
    UnsignedNumericValue
  | FunctionCall
  | Identifier
  | "(" ~ Expression ~ ")"
}

// TermNoImplicit is like Term but without ImplicitTimes - used for function bodies
// to prevent greedy matching across statement boundaries
TermNoImplicit = _{
    PartExtract
  | NumericValue
  | Constant
  | String
  | ListAnonymousFunction
  | List
  | FunctionAnonymousFunction
  | ParenAnonymousFunction
  | FunctionCall
  | SimpleAnonymousFunction
  | Identifier
  | Slot
  | Association
  | "(" ~ (CompoundExpression | Expression) ~ ")"
}

// ExpressionNoImplicit is like Expression but uses TermNoImplicit
ExpressionNoImplicit = {
    TermNoImplicit ~ (
        ("//." ~ (List | ReplacementRule)) |
        ("/." ~ (List | ReplacementRule)) |
        (Operator ~ TermNoImplicit)*
    )
    ~ ("//" ~ PostfixFunction)*
}

// Pattern: x_ or x_Head or x_?test or x_ /; condition
PatternTest = { PatternName ~ "_" ~ "?" ~ Identifier }
// ConditionExpr is like Expression but stops before -> and :> (rule operators)
// This prevents the condition from consuming the replacement part of a rule
ConditionExpr = {
    Term ~ (ConditionOp ~ Term)*
}
// Operators allowed in conditions - excludes -> and :> which mark rule boundaries
ConditionOp = {
    "===" | "=!=" | "==" | "!="  // Comparison
  | "<=" | ">=" | "<" | ">"       // Order comparison
  | "+" | "-" | "*" | "/" | "^"   // Arithmetic
  | "&&" | "||"                   // Logical
  | "/@" | "@@"                   // Map/Apply
}
PatternCondition = { PatternName ~ "_" ~ "/;" ~ ConditionExpr }
PatternWithHead = { PatternName ~ "_" ~ Identifier }
PatternSimple = { PatternName ~ "_" }
Pattern = { PatternCondition | PatternTest | PatternWithHead | PatternSimple }

// Replacement rule: pattern -> replacement or pattern :> replacement (RuleDelayed)
// PatternExpr can be a pattern or a term (for replacement rules)
ReplacementRule = { (PatternCondition | PatternTest | PatternWithHead | PatternSimple | Term) ~ ("->" | ":>") ~ Term }

// Replacement expressions: expr /. rule or expr //. rule
ReplaceAllExpr = { Term ~ "/." ~ (List | ReplacementRule) }
ReplaceRepeatedExpr = { Term ~ "//." ~ (List | ReplacementRule) }

List = { "{" ~ (ListItem ~ ("," ~ ListItem)*)? ~ "}" }
// ListItem can be a ReplacementRule (for rule lists) or an Expression
// ReplacementRule must be tried first because x_ -> y looks like Expression x_ followed by -> operator
ListItem = _{ ReplacementRule | Expression }

AssociationItem = { Expression ~ "->" ~ Expression }
Association     = { "<|" ~ ( AssociationItem ~ ("," ~ AssociationItem)* )? ~ "|>" }

// Function calls (supports chained calls like f[x][y])
// Simplified: Just use Expression for most args - patterns and compound expressions via Expression's Term
// FunctionArg can be a ReplacementRule, CompoundExpression, or Expression
FunctionArg = _{ ReplacementRule | CompoundExpression | Expression }
// BracketArgs groups arguments within a single bracket pair, allowing proper chained call parsing
BracketArgs = { "[" ~ (FunctionArg ~ ("," ~ FunctionArg)*)? ~ "]" }
FunctionCall = { (Identifier | SimpleAnonymousFunction) ~ BracketArgs+ }

// FunctionDefinition supports multiple pattern arguments: f[a_, b_] := ...
FunctionDefinitionPattern = _{ PatternCondition | PatternTest | PatternWithHead | PatternSimple }
// Body is a simple ExpressionNoImplicit (we removed CompoundExpression option to prevent
// greedy parsing of subsequent statements as part of the function body)
// Compound expressions in function bodies should use explicit parentheses: f[x_] := (a; b)
FunctionDefinition = { Identifier ~ "[" ~ (FunctionDefinitionPattern ~ ("," ~ FunctionDefinitionPattern)*)? ~ "]" ~ ":=" ~ ExpressionNoImplicit }

Statement = _{ FunctionDefinition | Expression }

// StatementSeparator can be a semicolon (traditional) or empty (relying on whitespace/newlines)
StatementSeparator = _{ ";"? }

Program = { SOI ~ Statement ~ (StatementSeparator ~ Statement)* ~ EOI }
