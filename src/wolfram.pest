WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "(*" ~ (!"*)" ~ ANY)* ~ "*)" }

// Part extraction suffix: [[expr, ...]] for indexing
PartIndexSuffix = { ("[[" ~ Expression ~ ("," ~ Expression)* ~ "]]")+ }

// PartExtract for non-FunctionCall bases only (Slot, Identifier)
// FunctionCall-based Part extraction is handled by FunctionCallExtended
// List-based Part extraction is handled by ListExtended
PartExtract = { (Slot | Identifier) ~ ("[[" ~ Expression ~ ("," ~ Expression)* ~ "]]")+ }

Integer = @{ ("-")? ~ ASCII_DIGIT+ }
Real = @{
    ("-")?
    ~ ((ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT*) | ("." ~ ASCII_DIGIT+))
    ~ ("*^" ~ ("-")? ~ ASCII_DIGIT+)?
}
UnsignedInteger = @{ ASCII_DIGIT+ }
UnsignedReal = @{
    (ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* | "." ~ ASCII_DIGIT+)
    ~ ("*^" ~ ("-")? ~ ASCII_DIGIT+)?
}
UnsignedConstant = { ("Pi" | "Degree" | "E") ~ !(ASCII_ALPHANUMERIC | "_") }
// Base-prefix literal: base^^digits (e.g. 16^^FF, 2^^1010)
BasePrefix = @{ ASCII_DIGIT+ ~ "^^" ~ (ASCII_ALPHANUMERIC)+ }
Constant = { ("-")? ~ ("Pi" | "Degree" | "E") ~ !(ASCII_ALPHANUMERIC | "_") }
NumericValue = { BasePrefix | Real | Integer | Constant }
UnsignedNumericValue = { BasePrefix | UnsignedReal | UnsignedInteger | UnsignedConstant }

// PatternName is an identifier that will be followed by _ in a Pattern
// It must start with a letter and can contain letters, digits, but NOT trailing underscores
PatternName = @{ (ASCII_ALPHA | LETTER) ~ (ASCII_ALPHANUMERIC | LETTER)* }
Identifier = @{ (ASCII_ALPHA | LETTER | "_" | "$") ~ (ASCII_ALPHANUMERIC | LETTER | "_")* }
String = @{ "\"" ~ ("\\\\" | "\\\"" | "\\n" | "\\t" | "\\r" | (!"\"" ~ !"\\" ~ ANY) | ("\\" ~ ANY))* ~ "\"" }

// Anonymous function syntax: body & where body contains # slots
Slot = @{ "#" ~ ASCII_DIGIT* }
// SimpleAnonymousFunction is # or # op term followed by & (not &&)
SimpleAnonymousFunction = { Slot ~ (Operator ~ SlotTerm)? ~ "&" ~ !"&" }
// SlotTerm is what can follow an operator in an anonymous function body
SlotTerm = _{ PartExtract | NumericValue | Constant | String | FunctionCall | Identifier | Slot | "(" ~ Expression ~ ")" }
// FunctionAnonymousFunction is a function call (like If[...]) followed by & (not &&)
// Optional BracketArgs allow direct calls: If[# > 0, #, 0]&[5]
FunctionAnonymousFunction = { BaseFunctionCall ~ "&" ~ !"&" ~ BracketArgs* }
// ParenAnonymousFunction handles (Expression)& - for expressions like (# === "")&
// Optional BracketArgs allow direct calls: (# + 1)&[5]
ParenAnonymousFunction = { "(" ~ (CompoundExpression | Expression) ~ ")" ~ "&" ~ !"&" ~ BracketArgs* }
// ListAnonymousFunction handles {expr1, expr2, ...}& - for expressions like {#1, #2}&
// Optional BracketArgs allow direct calls: {#, #^2}&[3]
ListAnonymousFunction = { List ~ "&" ~ !"&" ~ BracketArgs* }
// ListCall handles List used as a function head: {f, g}[x] → applies each element to args
ListCall = { List ~ BracketArgs+ }
// ListExtended merges List, ListAnonymousFunction, ListCall, and List-based
// PartExtract/PartAnonymousFunction into a single rule to avoid exponential
// backtracking. Parses List ONCE, then checks for optional suffixes.
// Named suffix rules for pair_to_expr detection.
ListAnonSuffix = { "&" ~ !"&" ~ BracketArgs* }
ListCallSuffix = { BracketArgs+ }
ListPartAnonSuffix = { (Operator ~ SlotTerm)* ~ "&" ~ !"&" ~ BracketArgs* }
ListExtended = {
    List ~ (
        PartIndexSuffix ~ ListPartAnonSuffix?   // List[[...]] or List[[...]]& (PartExtract/PartAnonymousFunction)
      | ListAnonSuffix                           // List& (ListAnonymousFunction)
      | ListCallSuffix                           // List[...] (ListCall)
    )?
}
// PartAnonymousFunction handles PartExtract& - for expressions like #[[2]]& or #[[1]] + #[[2]]&
// Only for non-FunctionCall bases (List/Slot/Identifier). FC-based handled by FunctionCallExtended.
// Optional BracketArgs allow direct calls: #[[2]]&[{3, 4, 5}]
PartAnonymousFunction = { PartExtract ~ (Operator ~ SlotTerm)* ~ "&" ~ !"&" ~ BracketArgs* }
// RuleAnonymousFunction handles ReplacementRule& - for expressions like {#, First@#2} -> "Q" &
RuleAnonymousFunction = { ReplacementRule ~ "&" ~ !"&" }
// BaseFunctionCall is a function call that doesn't include anonymous functions to avoid recursion
BaseFunctionCall = { Identifier ~ DerivativePrime? ~ ("[" ~ (FunctionArg ~ ("," ~ FunctionArg)*)? ~ "]")+ }

Operator = {
    "/@"     // keep first
  | "@@@"    // MapApply operator (must be before @@)
  | "@@"     // Apply operator (must be before single @)
  | "<>"     // StringJoin operator (must be before < and >)
  | "&&"     // And operator (must be before single &)
  | "||"     // Or operator (must be before single |)
  | "|"      // Alternatives operator
  | "===" | "=!=" | "==" | "!="  // SameQ, UnsameQ (must be before == and !=), Equal, Unequal
  | "<=" | ">="
  | ":>"     // RuleDelayed (must be before := and >)
  | ":="
  | "->"     // Rule (must be before - and >)
  | "+" | "-" | "*" | "/" | "^"
  | "." ~ !ASCII_DIGIT ~ !"."  // Dot operator (not decimal point, not .. or ...)
  | "<" | ">"
  | "=" | "@"
}

// PostfixFunction: function used in postfix application (x // f or x // Map[f])
// Uses BaseFunctionCall to avoid circular reference with FunctionCall -> FunctionArg -> Expression -> PostfixApplication
// Optional trailing & allows "x // f &" to parse as x // (f &), matching Wolfram precedence
PostfixFunction = { (BaseFunctionCall | Identifier) ~ ("&" ~ !"&")? }

// Increment/Decrement: x++ or x-- (postfix operators)
Increment = { Identifier ~ "++" }
Decrement = { Identifier ~ "--" }

// PreIncrement/PreDecrement: ++x or --x (prefix operators)
PreIncrement = { "++" ~ Identifier }
PreDecrement = { "--" ~ Identifier }

// Compound assignment: x += y, x -= y, x *= y, x /= y
AddTo = { Identifier ~ "+=" ~ Expression }
SubtractFrom = { Identifier ~ "-=" ~ Expression }
TimesBy = { Identifier ~ "*=" ~ Expression }
DivideBy = { Identifier ~ "/=" ~ Expression }

// ImplicitTimes handles implicit multiplication (e.g., "x y z" or "2 x")
// Each factor can have a power suffix so that "b y^3" parses as b*(y^3) not (b*y)^3
ImplicitPowerSuffix = { "^" ~ SimpleTerm }
ImplicitTimesFactor = _{ SimpleTerm ~ ImplicitPowerSuffix? }
ImplicitTimes = { ImplicitTimesFactor ~ ImplicitTimesFactor+ }

// Unified Expression: parses a base term/operators, then looks for optional postfix/replace operators
// This avoids redundant parsing by checking for special operators after the main parse
// Postfix application (//) has lowest precedence and can follow any expression form
// ReplaceAll (/.) and ReplaceRepeated (//.) can appear after operator chains: x = y /. rules
ReplaceAllSuffix = { "/." ~ (&HasRuleOperator ~ ReplacementRule | List | ConditionExpr) }
ReplaceRepeatedSuffix = { "//." ~ (&HasRuleOperator ~ ReplacementRule | List | ConditionExpr) }
// Repeated (..) and RepeatedNull (...) are postfix pattern operators
// "..." must be tried before ".." since PEG is ordered-choice
RepeatedNullSuffix = { "..." }
RepeatedSuffix = { ".." ~ !"." }
// AnonymousFunctionSuffix: & (not &&) at Expression level — lowest precedence
// Handles cases like #^2 + 1 &, # /. {rules} &, etc.
// Optional BracketArgs allow direct calls: (# /. rules &)[5]
AnonymousFunctionSuffix = { "&" ~ !"&" ~ BracketArgs* }
// LeadingMinus marks a leading "-" in an expression: -x, -f[x], -(a+b), etc.
// Only matches when NOT followed by a digit (so -3 still parses as negative Integer)
// Handled in parse_expression as a synthetic 0 - expr with proper precedence
LeadingMinus = { "-" ~ !ASCII_DIGIT }
// LeadingNot marks prefix "!" as Not[expr]: !True, !x, !(a && b), etc.
// Must not be followed by "=" (which would be != operator)
LeadingNot = { "!" ~ !"=" ~ !"!" }
// FactorialSuffix: n! or n!! (Factorial / Factorial2)
// Must not be followed by "=" (which would be != operator)
FactorialSuffix = { "!!" | "!" ~ !"=" ~ !"!" }
Expression = {
    (LeadingNot ~ Term ~ FactorialSuffix? | LeadingMinus ~ Term ~ FactorialSuffix? | Term ~ FactorialSuffix?) ~ (Operator ~ Term ~ FactorialSuffix?)*
    ~ (RepeatedNullSuffix | RepeatedSuffix)?   // Postfix: expr.. or expr...
    ~ (ReplaceRepeatedSuffix | ReplaceAllSuffix)?
    ~ ("//" ~ PostfixFunction)*               // Postfix application (lowest precedence): x // f
    ~ (AnonymousFunctionSuffix ~ (Operator ~ Term)* ~ ("//" ~ PostfixFunction)*)?  // Function: expr & (lowest precedence), then optional continuation
}

// Legacy rules kept for backward compatibility in evaluation code
PostfixBase = { ReplaceRepeatedExpr | ReplaceAllExpr | Term }
PostfixApplication = { PostfixBase ~ ("//" ~ PostfixFunction)+ }

// CompoundExpression: multiple expressions separated by ;
// The result is the value of the last expression (like Wolfram's CompoundExpression)
// A trailing ; means the result is Null (e.g. "a;" is CompoundExpression[a, Null])
// Uses single alternative to avoid parsing Expression twice for non-compound inputs.
CompoundExpression = { Expression ~ (";" ~ Expression?)+ }

// DerivativePrime: one or more ' characters after a function name (e.g. f', f'', f''')
// Transforms f'[x] → Derivative[1][f][x], f''[x] → Derivative[2][f][x], etc.
DerivativePrime = @{ "'"+ }
// DerivativeIdentifier: standalone f' or f'' without brackets → Derivative[n][f]
DerivativeIdentifier = { Identifier ~ DerivativePrime }

// FunctionCallExtended: merges FunctionCall, FunctionCall-based PartExtract,
// FunctionAnonymousFunction, and FunctionCall-based PartAnonymousFunction
// into a single rule. This parses the function call ONCE, then checks for
// optional Part extraction ([[...]]) or anonymous function (&) suffixes.
// This eliminates exponential backtracking caused by parsing the same
// FunctionCall 4 times through separate Term alternatives.
// Named suffix rules so pair_to_expr can detect them reliably.
FunctionCallAnonSuffix = { "&" ~ !"&" ~ BracketArgs* }
FunctionCallPartAnonSuffix = { (Operator ~ SlotTerm)* ~ "&" ~ !"&" ~ BracketArgs* }
FunctionCallExtended = {
    Identifier ~ DerivativePrime? ~ BracketArgs+
    ~ (
        PartIndexSuffix ~ FunctionCallPartAnonSuffix?
      | FunctionCallAnonSuffix
    )?
}

Term = _{
    PartAnonymousFunction
  | PartExtract
  | Constant
  | String
  | ListExtended
  | ParenAnonymousFunction
  | ImplicitTimes
  | FunctionCallExtended
  | NumericValue
  | AddTo
  | SubtractFrom
  | TimesBy
  | DivideBy
  | Increment
  | Decrement
  | PreIncrement
  | PreDecrement
  | PatternTest | PatternOptionalWithHead | PatternOptionalSimple | PatternWithHead | PatternSimple
  | DerivativeIdentifier
  | Identifier
  | Slot
  | Association
  | "(" ~ (CompoundExpression | Expression) ~ ")"
}

// SimpleTerm is used for implicit multiplication - doesn't include ImplicitTimes to avoid recursion
// Uses UnsignedNumericValue to prevent "n-1" from being parsed as implicit multiplication n*(-1)
SimpleTerm = _{
    UnsignedNumericValue
  | FunctionCall
  | DerivativeIdentifier
  | Identifier
  | Slot
  | List
  | "(" ~ Expression ~ ")"
}

// TermNoImplicit is like Term but without ImplicitTimes - used for function bodies
// to prevent greedy matching across statement boundaries
TermNoImplicit = _{
    PartAnonymousFunction
  | PartExtract
  | Constant
  | String
  | ListExtended
  | ParenAnonymousFunction
  | ImplicitTimes
  | FunctionCallExtended
  | NumericValue
  | AddTo
  | SubtractFrom
  | TimesBy
  | DivideBy
  | Increment
  | Decrement
  | PreIncrement
  | PreDecrement
  | PatternTest | PatternOptionalWithHead | PatternOptionalSimple | PatternWithHead | PatternSimple
  | DerivativeIdentifier
  | Identifier
  | Slot
  | Association
  | "(" ~ (CompoundExpression | Expression) ~ ")"
}

// ExpressionNoImplicit is like Expression but uses TermNoImplicit
ExpressionNoImplicit = {
    (LeadingNot ~ TermNoImplicit ~ FactorialSuffix? | LeadingMinus ~ TermNoImplicit ~ FactorialSuffix? | TermNoImplicit ~ FactorialSuffix?) ~ (Operator ~ TermNoImplicit ~ FactorialSuffix?)*
    ~ (RepeatedNullSuffix | RepeatedSuffix)?
    ~ (ReplaceRepeatedSuffix | ReplaceAllSuffix)?
    ~ ("//" ~ PostfixFunction)*
    ~ (AnonymousFunctionSuffix ~ (Operator ~ TermNoImplicit)* ~ ("//" ~ PostfixFunction)*)?
}

// Pattern: x_ or x_Head or x_?test or x_ /; condition or x_:default or x_Head:default
// PatternTest: x_?test or _?test or _?(expr) or x_?(expr)
// The test can be an Identifier or a parenthesized expression (e.g. anonymous function)
PatternTestFunc = _{ Identifier | "(" ~ (CompoundExpression | Expression) ~ ")" }
PatternTest = { PatternName? ~ "_" ~ "?" ~ PatternTestFunc }
// ConditionExpr is like Expression but stops before -> and :> (rule operators)
// This prevents the condition from consuming the replacement part of a rule
ConditionExpr = {
    (LeadingNot ~ Term ~ FactorialSuffix? | LeadingMinus ~ Term ~ FactorialSuffix? | Term ~ FactorialSuffix?) ~ (ConditionOp ~ Term ~ FactorialSuffix?)*
}
// Operators allowed in conditions - excludes -> and :> which mark rule boundaries
ConditionOp = {
    "===" | "=!=" | "==" | "!="  // Comparison
  | "<=" | ">=" | "<" | ">"       // Order comparison
  | "+" | "-" | "*" | "/" | "^"   // Arithmetic
  | "&&" | "||"                   // Logical
  | "/@" | "@@"                   // Map/Apply
}
PatternCondition = { PatternName ~ "_" ~ "/;" ~ ConditionExpr }
// PatternOptional: x_ : default or x_Head : default (Optional pattern with default value)
// Note: Wolfram uses both "x_:val" and "x_ : val" syntax. The colon must NOT be ":=" (SetDelayed)
PatternOptionalWithHead = { PatternName ~ "_" ~ Identifier ~ ":" ~ !("=" | ">") ~ Term }
PatternOptionalSimple = { PatternName ~ "_" ~ ":" ~ !("=" | ">") ~ Term }
PatternWithHead = { PatternName ~ "_" ~ Identifier }
PatternSimple = { PatternName ~ "_" }
Pattern = { PatternCondition | PatternTest | PatternOptionalWithHead | PatternOptionalSimple | PatternWithHead | PatternSimple }

// Replacement rule: pattern -> replacement or pattern :> replacement (RuleDelayed)
// The LHS is a ConditionExpr (expression that stops before -> and :>) with an optional /; condition.
// Patterns (x_, x_Head, etc.) can appear as terms within the LHS expression.
ReplacementRule = { ConditionExpr ~ ("/;" ~ ConditionExpr)? ~ ("->" | ":>") ~ ConditionExpr }

// Replacement expressions: expr /. rule or expr //. rule
ReplaceAllExpr = { Term ~ "/." ~ (&HasRuleOperator ~ ReplacementRule | List | ConditionExpr) }
ReplaceRepeatedExpr = { Term ~ "//." ~ (&HasRuleOperator ~ ReplacementRule | List | ConditionExpr) }

List = { "{" ~ (ListItem ~ ("," ~ ListItem)*)? ~ "}" }
// ListItem can be a ReplacementRule (with optional & suffix) or an Expression
// ReplacementRule must be tried first because x_ -> y looks like Expression x_ followed by -> operator
// RuleAnonymousFunction is merged with ReplacementRule to avoid parsing content twice.
// HasRuleOperator is a zero-width lookahead that scans for -> or :> at the current
// nesting depth. This avoids exponential backtracking for deeply nested lists by
// skipping the ReplacementRule attempt when no rule operator exists.
RuleAnonSuffix = { "&" ~ !"&" }
ListItemRule = { ReplacementRule ~ RuleAnonSuffix? }
// Scan forward looking for -> or :> at the current nesting depth
NestedContent = _{ (
    "{" ~ NestedContent ~ "}"
  | "[" ~ NestedContent ~ "]"
  | "(" ~ NestedContent ~ ")"
  | "\"" ~ (!("\"") ~ ANY)* ~ "\""
  | !("{" | "}" | "[" | "]" | "(" | ")" | "\"") ~ ANY
)* }
HasRuleOperator = _{ (
    "{" ~ NestedContent ~ "}"
  | "[" ~ NestedContent ~ "]"
  | "(" ~ NestedContent ~ ")"
  | "\"" ~ (!("\"") ~ ANY)* ~ "\""
  | !("->" | ":>" | "}" | "," | "]" | ")" | "\"") ~ ANY
)* ~ ("->" | ":>") }
ListItem = _{ &HasRuleOperator ~ ListItemRule | Expression }

AssociationItem = { ConditionExpr ~ "->" ~ ConditionExpr }
Association     = { "<|" ~ ( AssociationItem ~ ("," ~ AssociationItem)* )? ~ "|>" }

// Function calls (supports chained calls like f[x][y])
// Simplified: Just use Expression for most args - patterns and compound expressions via Expression's Term
// FunctionArg: ReplacementRule (with optional & suffix), CompoundExpression, or Expression
// Merged RuleAnonymousFunction with ReplacementRule to reduce backtracking.
// Uses HasRuleOperator lookahead to skip rule parsing when no rule operator exists.
FunctionArgRule = { ReplacementRule ~ RuleAnonSuffix? }
FunctionArg = _{ &HasRuleOperator ~ FunctionArgRule | CompoundExpression | Expression }
// BracketArgs groups arguments within a single bracket pair, allowing proper chained call parsing
BracketArgs = { "[" ~ (FunctionArg ~ ("," ~ FunctionArg)*)? ~ "]" }
FunctionCall = { (Identifier | SimpleAnonymousFunction) ~ DerivativePrime? ~ BracketArgs+ }

// FunctionDefinition supports multiple pattern arguments: f[a_, b_] := ...
FunctionDefinitionPattern = _{ PatternCondition | PatternTest | PatternOptionalWithHead | PatternOptionalSimple | PatternWithHead | PatternSimple }
// Body is a simple ExpressionNoImplicit (we removed CompoundExpression option to prevent
// greedy parsing of subsequent statements as part of the function body)
// Compound expressions in function bodies should use explicit parentheses: f[x_] := (a; b)
FunctionDefinition = { Identifier ~ "[" ~ (FunctionDefinitionPattern ~ ("," ~ FunctionDefinitionPattern)*)? ~ "]" ~ ":=" ~ ExpressionNoImplicit }

Statement = _{ FunctionDefinition | Expression }

// StatementSeparator can be a semicolon (traditional) or empty (relying on whitespace/newlines)
StatementSeparator = _{ ";"? }

// TrailingSemicolon marks that the last statement ends with ; (suppresses output)
TrailingSemicolon = { ";" }

Program = { SOI ~ Statement ~ (StatementSeparator ~ Statement)* ~ TrailingSemicolon? ~ EOI }
