WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "(*" ~ (!"*)" ~ ANY)* ~ "*)" }

PartExtract = { (FunctionCall | List | Identifier) ~ ("[[" ~ Expression ~ ("," ~ Expression)* ~ "]]")+ }

Integer = @{ ("-")? ~ ASCII_DIGIT+ }
Real = @{ ("-")? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
UnsignedInteger = @{ ASCII_DIGIT+ }
UnsignedReal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
// Base-prefix literal: base^^digits (e.g. 16^^FF, 2^^1010)
BasePrefix = @{ ASCII_DIGIT+ ~ "^^" ~ (ASCII_ALPHANUMERIC)+ }
Constant = { ("-")? ~ ("Pi" | "Degree" | "E") ~ !(ASCII_ALPHANUMERIC | "_") }
NumericValue = { BasePrefix | Real | Integer | Constant }
UnsignedNumericValue = { BasePrefix | UnsignedReal | UnsignedInteger | Constant }

// PatternName is an identifier that will be followed by _ in a Pattern
// It must start with a letter and can contain letters, digits, but NOT trailing underscores
PatternName = @{ (ASCII_ALPHA | LETTER) ~ (ASCII_ALPHANUMERIC | LETTER)* }
Identifier = @{ (ASCII_ALPHA | LETTER | "_" | "$") ~ (ASCII_ALPHANUMERIC | LETTER | "_")* }
String = @{ "\"" ~ ("\\\\" | "\\\"" | "\\n" | "\\t" | "\\r" | (!"\"" ~ !"\\" ~ ANY) | ("\\" ~ ANY))* ~ "\"" }

// Anonymous function syntax: body & where body contains # slots
Slot = @{ "#" ~ ASCII_DIGIT* }
// SimpleAnonymousFunction is # or # op term followed by & (not &&)
SimpleAnonymousFunction = { Slot ~ (Operator ~ SlotTerm)? ~ "&" ~ !"&" }
// SlotTerm is what can follow an operator in a simple anonymous function
SlotTerm = _{ NumericValue | Constant | String | Identifier | Slot | "(" ~ Expression ~ ")" }
// FunctionAnonymousFunction is a function call (like If[...]) followed by & (not &&)
// Optional BracketArgs allow direct calls: If[# > 0, #, 0]&[5]
FunctionAnonymousFunction = { BaseFunctionCall ~ "&" ~ !"&" ~ BracketArgs* }
// ParenAnonymousFunction handles (Expression)& - for expressions like (# === "")&
// Optional BracketArgs allow direct calls: (# + 1)&[5]
ParenAnonymousFunction = { "(" ~ (CompoundExpression | Expression) ~ ")" ~ "&" ~ !"&" ~ BracketArgs* }
// ListAnonymousFunction handles {expr1, expr2, ...}& - for expressions like {#1, #2}&
// Optional BracketArgs allow direct calls: {#, #^2}&[3]
ListAnonymousFunction = { List ~ "&" ~ !"&" ~ BracketArgs* }
// RuleAnonymousFunction handles ReplacementRule& - for expressions like {#, First@#2} -> "Q" &
RuleAnonymousFunction = { ReplacementRule ~ "&" ~ !"&" }
// BaseFunctionCall is a function call that doesn't include anonymous functions to avoid recursion
BaseFunctionCall = { Identifier ~ ("[" ~ (FunctionArg ~ ("," ~ FunctionArg)*)? ~ "]")+ }

Operator = {
    "/@"     // keep first
  | "@@@"    // MapApply operator (must be before @@)
  | "@@"     // Apply operator (must be before single @)
  | "<>"     // StringJoin operator (must be before < and >)
  | "&&"     // And operator (must be before single &)
  | "||"     // Or operator (must be before single |)
  | "|"      // Alternatives operator
  | "===" | "=!=" | "==" | "!="  // SameQ, UnsameQ (must be before == and !=), Equal, Unequal
  | "<=" | ">="
  | ":>"     // RuleDelayed (must be before := and >)
  | ":="
  | "->"     // Rule (must be before - and >)
  | "+" | "-" | "*" | "/" | "^"
  | "." ~ !ASCII_DIGIT  // Dot operator (not decimal point)
  | "<" | ">"
  | "=" | "@"
}

// PostfixFunction: function used in postfix application (x // f or x // Map[f])
// Uses BaseFunctionCall to avoid circular reference with FunctionCall -> FunctionArg -> Expression -> PostfixApplication
PostfixFunction = { BaseFunctionCall | Identifier }

// Increment/Decrement: x++ or x-- (postfix operators)
Increment = { Identifier ~ "++" }
Decrement = { Identifier ~ "--" }

// Compound assignment: x += y, x -= y, x *= y, x /= y
AddTo = { Identifier ~ "+=" ~ Expression }
SubtractFrom = { Identifier ~ "-=" ~ Expression }
TimesBy = { Identifier ~ "*=" ~ Expression }
DivideBy = { Identifier ~ "/=" ~ Expression }

// ImplicitTimes handles implicit multiplication (e.g., "x y z" or "2 x")
ImplicitTimes = { SimpleTerm ~ SimpleTerm+ }

// Unified Expression: parses a base term/operators, then looks for optional postfix/replace operators
// This avoids redundant parsing by checking for special operators after the main parse
// Postfix application (//) has lowest precedence and can follow any expression form
// ReplaceAll (/.) and ReplaceRepeated (//.) can appear after operator chains: x = y /. rules
ReplaceAllSuffix = { "/." ~ (List | ReplacementRule) }
ReplaceRepeatedSuffix = { "//." ~ (List | ReplacementRule) }
// LeadingMinus marks a leading "-" in an expression: -x, -f[x], -(a+b), etc.
// Only matches when NOT followed by a digit (so -3 still parses as negative Integer)
// Handled in parse_expression as a synthetic 0 - expr with proper precedence
LeadingMinus = { "-" ~ !ASCII_DIGIT }
Expression = {
    (LeadingMinus ~ Term | Term) ~ (Operator ~ Term)*
    ~ (ReplaceRepeatedSuffix | ReplaceAllSuffix)?
    ~ ("//" ~ PostfixFunction)*               // Postfix application (lowest precedence): x // f
}

// Legacy rules kept for backward compatibility in evaluation code
PostfixBase = { ReplaceRepeatedExpr | ReplaceAllExpr | Term }
PostfixApplication = { PostfixBase ~ ("//" ~ PostfixFunction)+ }

// CompoundExpression: multiple expressions separated by ;
// The result is the value of the last expression (like Wolfram's CompoundExpression)
// A trailing ; means the result is Null (e.g. "a;" is CompoundExpression[a, Null])
CompoundExpression = { Expression ~ (";" ~ Expression)+ ~ ";"? | Expression ~ ";" }
Term = _{
    PartExtract
  | Constant
  | String
  | ListAnonymousFunction
  | List
  | FunctionAnonymousFunction
  | ParenAnonymousFunction
  | FunctionCall
  | SimpleAnonymousFunction
  | ImplicitTimes
  | NumericValue
  | AddTo
  | SubtractFrom
  | TimesBy
  | DivideBy
  | Increment
  | Decrement
  | Identifier
  | Slot
  | Association
  | "(" ~ (CompoundExpression | Expression) ~ ")"
}

// SimpleTerm is used for implicit multiplication - doesn't include ImplicitTimes to avoid recursion
// Uses UnsignedNumericValue to prevent "n-1" from being parsed as implicit multiplication n*(-1)
SimpleTerm = _{
    UnsignedNumericValue
  | FunctionCall
  | Identifier
  | Slot
  | "(" ~ Expression ~ ")"
}

// TermNoImplicit is like Term but without ImplicitTimes - used for function bodies
// to prevent greedy matching across statement boundaries
TermNoImplicit = _{
    PartExtract
  | Constant
  | String
  | ListAnonymousFunction
  | List
  | FunctionAnonymousFunction
  | ParenAnonymousFunction
  | FunctionCall
  | SimpleAnonymousFunction
  | ImplicitTimes
  | NumericValue
  | AddTo
  | SubtractFrom
  | TimesBy
  | DivideBy
  | Increment
  | Decrement
  | Identifier
  | Slot
  | Association
  | "(" ~ (CompoundExpression | Expression) ~ ")"
}

// ExpressionNoImplicit is like Expression but uses TermNoImplicit
ExpressionNoImplicit = {
    (LeadingMinus ~ TermNoImplicit | TermNoImplicit) ~ (Operator ~ TermNoImplicit)*
    ~ (ReplaceRepeatedSuffix | ReplaceAllSuffix)?
    ~ ("//" ~ PostfixFunction)*
}

// Pattern: x_ or x_Head or x_?test or x_ /; condition or x_:default or x_Head:default
PatternTest = { PatternName ~ "_" ~ "?" ~ Identifier }
// ConditionExpr is like Expression but stops before -> and :> (rule operators)
// This prevents the condition from consuming the replacement part of a rule
ConditionExpr = {
    (LeadingMinus ~ Term | Term) ~ (ConditionOp ~ Term)*
}
// Operators allowed in conditions - excludes -> and :> which mark rule boundaries
ConditionOp = {
    "===" | "=!=" | "==" | "!="  // Comparison
  | "<=" | ">=" | "<" | ">"       // Order comparison
  | "+" | "-" | "*" | "/" | "^"   // Arithmetic
  | "&&" | "||"                   // Logical
  | "/@" | "@@"                   // Map/Apply
}
PatternCondition = { PatternName ~ "_" ~ "/;" ~ ConditionExpr }
// PatternOptional: x_ : default or x_Head : default (Optional pattern with default value)
// Note: Wolfram uses both "x_:val" and "x_ : val" syntax. The colon must NOT be ":=" (SetDelayed)
PatternOptionalWithHead = { PatternName ~ "_" ~ Identifier ~ ":" ~ !("=" | ">") ~ Term }
PatternOptionalSimple = { PatternName ~ "_" ~ ":" ~ !("=" | ">") ~ Term }
PatternWithHead = { PatternName ~ "_" ~ Identifier }
PatternSimple = { PatternName ~ "_" }
Pattern = { PatternCondition | PatternTest | PatternOptionalWithHead | PatternOptionalSimple | PatternWithHead | PatternSimple }

// Replacement rule: pattern -> replacement or pattern :> replacement (RuleDelayed)
// PatternExpr can be a pattern or a term (for replacement rules)
ReplacementRule = { (PatternCondition | PatternTest | PatternWithHead | PatternSimple | Term) ~ ("->" | ":>") ~ Term }

// Replacement expressions: expr /. rule or expr //. rule
ReplaceAllExpr = { Term ~ "/." ~ (List | ReplacementRule) }
ReplaceRepeatedExpr = { Term ~ "//." ~ (List | ReplacementRule) }

List = { "{" ~ (ListItem ~ ("," ~ ListItem)*)? ~ "}" }
// ListItem can be a ReplacementRule (for rule lists) or an Expression
// ReplacementRule must be tried first because x_ -> y looks like Expression x_ followed by -> operator
ListItem = _{ RuleAnonymousFunction | ReplacementRule | Expression }

AssociationItem = { ConditionExpr ~ "->" ~ ConditionExpr }
Association     = { "<|" ~ ( AssociationItem ~ ("," ~ AssociationItem)* )? ~ "|>" }

// Function calls (supports chained calls like f[x][y])
// Simplified: Just use Expression for most args - patterns and compound expressions via Expression's Term
// FunctionArg can be a ReplacementRule, CompoundExpression, or Expression
FunctionArg = _{ RuleAnonymousFunction | ReplacementRule | CompoundExpression | Expression }
// BracketArgs groups arguments within a single bracket pair, allowing proper chained call parsing
BracketArgs = { "[" ~ (FunctionArg ~ ("," ~ FunctionArg)*)? ~ "]" }
FunctionCall = { (Identifier | SimpleAnonymousFunction) ~ BracketArgs+ }

// FunctionDefinition supports multiple pattern arguments: f[a_, b_] := ...
FunctionDefinitionPattern = _{ PatternCondition | PatternTest | PatternOptionalWithHead | PatternOptionalSimple | PatternWithHead | PatternSimple }
// Body is a simple ExpressionNoImplicit (we removed CompoundExpression option to prevent
// greedy parsing of subsequent statements as part of the function body)
// Compound expressions in function bodies should use explicit parentheses: f[x_] := (a; b)
FunctionDefinition = { Identifier ~ "[" ~ (FunctionDefinitionPattern ~ ("," ~ FunctionDefinitionPattern)*)? ~ "]" ~ ":=" ~ ExpressionNoImplicit }

Statement = _{ FunctionDefinition | Expression }

// StatementSeparator can be a semicolon (traditional) or empty (relying on whitespace/newlines)
StatementSeparator = _{ ";"? }

// TrailingSemicolon marks that the last statement ends with ; (suppresses output)
TrailingSemicolon = { ";" }

Program = { SOI ~ Statement ~ (StatementSeparator ~ Statement)* ~ TrailingSemicolon? ~ EOI }
