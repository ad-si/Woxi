WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "(*" ~ (!"*)" ~ ANY)* ~ "*)" }

PartExtract = { (List | Identifier) ~ "[[" ~ Expression ~ "]]" }

Integer = @{ ("-")? ~ ASCII_DIGIT+ }
Real = @{ ("-")? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
Constant = { ("-")? ~ "Pi" }
NumericValue = { Real | Integer | Constant }

// PatternName is an identifier that will be followed by _ in a Pattern
// It must start with a letter and can contain letters, digits, but NOT trailing underscores
PatternName = @{ ASCII_ALPHA ~ ASCII_ALPHANUMERIC* }
Identifier = @{ (ASCII_ALPHA | "_" | "$") ~ (ASCII_ALPHANUMERIC | "_")* }
String = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Anonymous function syntax: body & where body contains # slots
Slot = @{ "#" ~ ASCII_DIGIT* }
// SimpleAnonymousFunction is # or # op term followed by & (not &&)
SimpleAnonymousFunction = { Slot ~ (Operator ~ SlotTerm)? ~ "&" ~ !"&" }
// SlotTerm is what can follow an operator in a simple anonymous function
SlotTerm = _{ NumericValue | Constant | String | Identifier | Slot | "(" ~ Expression ~ ")" }
// FunctionAnonymousFunction is a function call (like If[...]) followed by & (not &&)
FunctionAnonymousFunction = { BaseFunctionCall ~ "&" ~ !"&" }
// BaseFunctionCall is a function call that doesn't include anonymous functions to avoid recursion
BaseFunctionCall = { Identifier ~ ("[" ~ (FunctionArg ~ ("," ~ (FunctionArg | List))*)? ~ "]")+ }

Operator = {
    "/@"     // keep first
  | "@@"     // Apply operator (must be before single @)
  | "<>"     // StringJoin operator (must be before < and >)
  | "&&"     // And operator (must be before single &)
  | "||"     // Or operator
  | "===" | "==" | "!="  // SameQ (must be before ==), Equal, Unequal
  | "<=" | ">="
  | ":="
  | "+" | "-" | "*" | "/" | "^"
  | "<" | ">"
  | "=" | "@"
}

// PostfixFunction: function used in postfix application (x // f or x // Map[f])
// Uses BaseFunctionCall to avoid circular reference with FunctionCall -> FunctionArg -> Expression -> PostfixApplication
PostfixFunction = { BaseFunctionCall | Identifier }

// PostfixApplication: term // f or (expr /. ...) // f
// PostfixBase is what can appear before //
PostfixBase = { ReplaceRepeatedExpr | ReplaceAllExpr | Term }
PostfixApplication = { PostfixBase ~ ("//" ~ PostfixFunction)+ }

// ImplicitTimes handles implicit multiplication (e.g., "x y z" or "2 x")
ImplicitTimes = { SimpleTerm ~ SimpleTerm+ }

Expression = { PostfixApplication | ReplaceRepeatedExpr | ReplaceAllExpr | Term ~ (Operator ~ Term)* }

// CompoundExpression: multiple expressions separated by ;
// The result is the value of the last expression (like Wolfram's CompoundExpression)
CompoundExpression = { Expression ~ (";" ~ Expression)+ }
Term = _{
    PartExtract
  | NumericValue
  | Constant
  | String
  | List
  | FunctionAnonymousFunction
  | FunctionCall
  | SimpleAnonymousFunction
  | ImplicitTimes
  | Identifier
  | Slot
  | Association
  | "(" ~ Expression ~ ")"
}

// SimpleTerm is used for implicit multiplication - doesn't include ImplicitTimes to avoid recursion
SimpleTerm = _{
    NumericValue
  | Constant
  | FunctionCall
  | Identifier
  | "(" ~ Expression ~ ")"
}

// Pattern: x_ or x_?test or x_ /; condition
PatternTest = { PatternName ~ "_" ~ "?" ~ Identifier }
PatternCondition = { PatternName ~ "_" ~ "/;" ~ Expression }
PatternSimple = { PatternName ~ "_" }
Pattern = { PatternCondition | PatternTest | PatternSimple }

// Replacement rule: pattern -> replacement or pattern :> replacement (RuleDelayed)
// PatternExpr can be a pattern or a term (for replacement rules)
ReplacementRule = { (PatternCondition | PatternTest | PatternSimple | Term) ~ ("->" | ":>") ~ Term }

// Replacement expressions: expr /. rule or expr //. rule
ReplaceAllExpr = { Term ~ "/." ~ (List | ReplacementRule) }
ReplaceRepeatedExpr = { Term ~ "//." ~ (List | ReplacementRule) }

List = { "{" ~ (ListItem ~ ("," ~ ListItem)*)? ~ "}" }
ListItem = _{ ReplacementRule | Expression }

AssociationItem = { Expression ~ "->" ~ Expression }
Association     = { "<|" ~ ( AssociationItem ~ ("," ~ AssociationItem)* )? ~ "|>" }

// Function calls (supports chained calls like f[x][y])
// Arguments can be Patterns (for function definitions), CompoundExpressions, Expressions, or ReplacementRules
FunctionArg = _{ PatternCondition | PatternTest | PatternSimple | ReplacementRule | CompoundExpression | Expression }
FunctionCall = { (Identifier | SimpleAnonymousFunction) ~ ("[" ~ (FunctionArg ~ ("," ~ (FunctionArg | List))*)? ~ "]")+ }

// FunctionDefinition supports multiple pattern arguments: f[a_, b_] := ...
FunctionDefinitionPattern = _{ PatternCondition | PatternTest | PatternSimple }
FunctionDefinition = { Identifier ~ "[" ~ (FunctionDefinitionPattern ~ ("," ~ FunctionDefinitionPattern)*)? ~ "]" ~ ":=" ~ Expression }

Statement = _{ FunctionDefinition | Expression }

// StatementSeparator can be a semicolon (traditional) or empty (relying on whitespace/newlines)
StatementSeparator = _{ ";"? }

Program = { SOI ~ Statement ~ (StatementSeparator ~ Statement)* ~ EOI }
